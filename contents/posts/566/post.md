---
title: 自力で複雑なフォームを実装するときに考えること
time: 2026-01-26 21:15
tags: ['react']
---

普段、たいていのフォームを実装する際には[conform](https://conform.guide/)を使っているのだけど、たまに当てはめにくい複雑なフォームを実装することがある。便利ライブラリに頼り切っていると、こういうときに困る。ただでさえ簡単フォームですら自力で実装する経験が乏しいのに、とても複雑なフォームを一から実装するのは毎回骨が折れる。

というわけで、conformなどの便利ライブラリを使わずに自力で複雑なフォームを実装するときに考えていることをあらためて整理してみた。Reactの公式ドキュメントを読みながら実践してきたことを整理しているので、公式ドキュメントに書いてあることも含まれる。実践を続けるなかで修正したり追加していくこともあると思う。

# 前提
- conformなどのフォーム状態管理ライブラリを使わない一方で、shadcnのようなコンポーネントライブラリやzodなどのバリデーションライブラリは利用する。
- アクセシビリティはコンポーネントレベルで考えるとして、ここでは割愛する。

# 状態のモデリング
- フィールドの値を表す状態はひとつにまとめる。
  - 理由：個別に状態を分けることもできるけど、まとめた方が複雑になったときに対応しやすい。例えば、フィールド間に依存関係があると、複数のフィールドを同時に更新することになるため、状態をまとめた方が整合性を保ちやすくなる。
  - 理由： `useReducer` を使いreducerによって状態を更新する場合、必然的に状態をまとめることになる。
- フィールドの値を表す状態とエラーを表す状態は分ける。
  - 理由：フィールドの値とエラーは異なるタイミングで更新されるため。
- ドメインモデルとして状態をモデリングしない。
  - 理由：状態はあくまでもフィールドの値を表すものにすぎないため。
- 状態の更新ロジックが複雑になったら、 `useReducer` を使ってイベントハンドラをアクションのdispatcherとして責務にとどめ、アクションに基づいて状態を更新する責務はreducerに委譲する。
  - 理由：イベントハンドラは状態を更新する以外の責務も持ちうるため、イベントハンドラの肥大化を回避したい。
  - 理由：複雑な状態更新ロジックをreducerという純粋関数に閉じ込めることでテストしやすくなる。

# controlled vs uncontrolled
- まずはuncontrolled componentとして実装し、必要があるときだけcontrolledにする。必要があるときというのは例えば、入力値によって他のフィールドが動的に変化する場合、 `onSubmit` よりも早いタイミングでバリデーションしたい場合、ユーザーの入力以外の方法で値を更新したい場合（APIリクエストやリセットなど）が考えられる。
  - 理由：一般論として、状態は多ければ多いほどその組み合わせによって複雑になるため、できるだけ状態は持たない方がいい。
  - 理由：状態が多いほど、再レンダリングされる頻度が増えてパフォーマンスが悪化しやすくなる。
  - Tips：`onSubmit` のイベントハンドラで `FormData` を参照することで、uncontrolled componentのフィールドの値を参照できる。
    ```tsx
    const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
      event.preventDefault();

      const formData = new FormData(event.currentTarget);
      const values = Object.fromEntries(formData.entries());
      // バリデーションなど
    };
    ```

# 動的に増減するフィールド
- 動的に増減するフィールドはindexではなくIDで管理する。
  - 理由：フィールドを並び替えたり削除するとindexがずれるため、意図しない不具合が出やすい。
  - 理由：indexを `key` 属性に使うは推奨されていない。
  - Tips：IDとして利用できる値がなければ、 `crypto.randomUUID()` を使って生成する。ブラウザでもSSR時にも使えるので使いやすい。
- 状態のなかでIDを持つエンティティがネストする場合は正規化する。こんなイメージ。
  ```tsx
  [
    orders: {
      "1": { id: "1", productIds: ["1", "2"] },
      "2": { id: "2", productIds: ["2", "3"] },
    },
    products: {
      "1": { id: "1", name: "product1" },
      "2": { id: "2", name: "product2" },
      "3": { id: "3", name: "product3" },
    },
  ]
  ```
  - 理由：状態内で不整合が発生しにくくなるため。
  - 理由：深くネストしたフィールドを更新するのは実装に手間がかかるため。
  - 理由：バリデーションエラーをフィールドに紐づける際にこの形式だとマッピングしやすい。
- Tips：複雑な構造を持つフィールドの `name` 属性はバックエンドで利用するパーサーが利用する命名規則に従う。例えば、[qs](https://github.com/ljharb/qs)を使う場合、以下のような命名規則に従うことになる。
  ```tsx
  {products.map((product) => (
    <Fragment key={product.id}>
      <input name={`product[${product.id}].name`} />
    </Fragment>
  ))}
  ```

# ウィザード型フォーム
- ウィザード自体の状態と、ウィザードを構成する各フォームの状態を分離する。各フォームが検証した、信頼できる値のみをウィザードが保持する。
  - 理由：ステップを戻ったときに以前に入力した値を初期値として渡せるようにするため。
  - 理由：状態が肥大化するのを回避し、ウィザードと各フォームを疎結合に保つため。
