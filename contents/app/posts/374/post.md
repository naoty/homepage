---
title: bit全探索
time: 2019-06-30T23:01:00+0900
tags: ["algorythm"]
---

ある集合のすべての組み合わせを列挙したいときに、bit全探索と呼ばれるアルゴリズムを使うといいことを学んだ。

```cpp
int main() {
  int n = 3;

  // 組み合わせの数だけループする
  for (int bit = 0; bit < (1 << n); bit++) {
    // 組み合わせに含まれる要素
    vector<int> numbers;

    // 全要素についてループする
    for (int i = 0; i < n; i++) {
      // 要素が組み合わせに含まれるかチェックする
      if (bit & (1 << i)) {
        // 組み合わせに要素を追加する
        numbers.push_back(i);
      }
    }

    printf("{");
    for (int i = 0; i < numbers.size(); i++) {
      printf((i == 0) ? "%d" : " %d", numbers[i]); 
    }
    printf("} ");
  }
  printf("\n");
}
```

```bash
$ ./a.out
{} {0} {1} {0 1} {2} {0 2} {1 2} {0 1 2}
```

# 組み合わせの数

```cpp
for (int bit = 0; bit < (1 << n); bit++) {
}
```

ある集合のすべての組み合わせは、各要素について含めるか含めないかの2択によって生まれるので、`2^<要素数>`になる。`1 << n`は`2^n`と同じなので、組み合わせの数だけループしていることになる。

# 組み合わせの作り方

```cpp
for (int i = 0; i < n; i++) {
  if (bit & (1 << i)) {
  }
}
```

`bit & (1 << i)`は要素`i`が組み合わせに含まれるかをチェックしている。`&`はAND演算なので、`bit`と`(1 << i)`をそれぞれ2進数として考える。

`bit`は上のコードだと`0`から`7`までの数になるので、2進数では`000`から`111`までということになる。

一方、`i`は上のコードだと`0`, `1`, `2`なので、`(1 << i)`はそれぞれ`001`, `010`, `100`になる。

なので、`bit`が`000`だったらどの要素も含まれないことになるし、`101`だったら`0`と`2`が含まれることになる。つまり、要素の組み合わせを`bit`が示す2進数で表していると言える。
